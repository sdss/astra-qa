---
title: "ASPCAP"
bibliography: bibliography.bib
author:
  - name: Person 1
    affiliation: 
     - id: wwu
       name: Place 1

  - name: Person 2
    affiliation: 
      - ref: wwu
    corresponding: true
---



```{python}
import numpy as np
import matplotlib.pyplot as plt
from astropy.table import Table
from astra.utils import expand_path
from astra.models import Source

import astra_qa as qa
from astra import __version__
from astra.models import (
    ASPCAP as MODEL,
    ApogeeVisitSpectrumInApStar as VISIT_SPECTRUM_MODEL,
    ApogeeCoaddedSpectrumInApStar as COADD_SPECTRUM_MODEL
)
```


# Scientific verification

## The Sun


```{python}
#| label: tbl-solar-parameters
#| tbl-cap: Stellar parameters inferred given a Solar spectrum

qa.render_all_solar_results_pivot(MODEL)
```

```{python}
#| label: fig-hrd
#| fig-cap: "Kiel diagram of all unflagged results reported by this pipeline (on coadds and visits)."

data = np.atleast_2d(
    list(
        MODEL
        .select(
            MODEL.teff,
            MODEL.logg,
            MODEL.raw_m_h_atm,
        )
        .where(~MODEL.flag_bad)
        .tuples()
    )
)

fig = qa.plot_kiel_two_panel(
    *data.T,
    x_lims=(2500, 7000),
    y_lims=(0, 6),
)
```


## IRFM temperatures

### Giants

```{python}
import numpy as np
from peewee import fn
from astropy.table import Table
from astra.models import ASPCAP, Source

import matplotlib.pyplot as plt
from matplotlib.colors import LogNorm
from scipy.stats import binned_statistic_2d

q = (
    ASPCAP
    .select(
        ASPCAP.source_pk,
        ASPCAP.spectrum_pk,
        ASPCAP.teff,
        ASPCAP.irfm_teff,
        ASPCAP.raw_teff,
        ASPCAP.logg,
        ASPCAP.raw_logg,
        ASPCAP.m_h_atm,        
        Source.v_jkc_mag,
        Source.k_mag,
        Source.ebv,
        Source.e_ebv,
        Source.ebv_flags,   
        ASPCAP.irfm_teff_flags,     
    )
    .distinct(ASPCAP.spectrum_pk)
    .join(Source)
    .where(
        ASPCAP.irfm_teff.is_null(False)
    &   (~ASPCAP.flag_ferre_fail)
    &   (~ASPCAP.flag_missing_model_flux)
    &   (~ASPCAP.flag_potential_ferre_timeout)
    &   (~ASPCAP.flag_no_suitable_initial_guess)
    &   (~ASPCAP.flag_spectrum_io_error)
    &   (~ASPCAP.flag_teff_grid_edge_warn)
    &   (~ASPCAP.flag_teff_grid_edge_bad)
    &   (~ASPCAP.flag_logg_grid_edge_warn)
    &   (~ASPCAP.flag_logg_grid_edge_bad)
    &   (~ASPCAP.flag_v_micro_grid_edge_warn)
    &   (~ASPCAP.flag_v_micro_grid_edge_bad)
    &   (~ASPCAP.flag_v_sini_grid_edge_warn)
    &   (~ASPCAP.flag_v_sini_grid_edge_bad)
    &   (~ASPCAP.flag_m_h_atm_grid_edge_warn)
    &   (~ASPCAP.flag_m_h_atm_grid_edge_bad)
    &   (~ASPCAP.flag_alpha_m_grid_edge_warn)
    &   (~ASPCAP.flag_alpha_m_grid_edge_bad)
    &   (~ASPCAP.flag_c_m_atm_grid_edge_warn)
    &   (~ASPCAP.flag_c_m_atm_grid_edge_bad)
    &   (~ASPCAP.flag_n_m_atm_grid_edge_warn)
    &   (~ASPCAP.flag_n_m_atm_grid_edge_bad)
    &   (Source.ebv < 0.05)
    &   (Source.ebv >= 0)
    &   (~ASPCAP.flag_out_of_fe_h_bounds)
    &   (~ASPCAP.flag_extrapolated_v_mag)
    &   (~ASPCAP.flag_poor_quality_k_mag)
    &   (~ASPCAP.flag_ebv_used_is_upper_limit)
    &   ASPCAP.flag_as_giant_for_irfm_teff 
    &   (fn.abs(ASPCAP.teff - ASPCAP.irfm_teff) < 500)
    &   (ASPCAP.raw_teff <= 5750)
    &   ~(Source.flag_ebv_from_edenhofer_2023) 
    )
    .dicts()    
)

results = Table(rows=list(q))


def plot_binned_statistic(
    x, y, z=None,
    bins=100,
    function="count",
    xlabel=None,
    ylabel=None,
    zlabel=None,
    ax=None,
    colorbar=False,
    figsize=(8, 8),
    vmin=None,
    vmax=None,
    min_entries_per_bin=None,
    subsample=None,
    mask=None,
    orientation="vertical",
    full_output=False,
    **kwargs
):
    if z is None and function != "count":
        raise ValueError("z must be given if not counting")
    
    if z is None:
        z = y
    
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=figsize)
    else:
        fig = ax.figure
    
    finite = np.isfinite(x * y * z)
    if mask is not None:
        finite *= mask
    if subsample is not None:
        idx = np.where(finite)[0]
        if subsample < 1:
            subsample *= idx.size
        if int(subsample) > idx.size:
            finite = idx
        else:
            finite = np.random.choice(idx, int(subsample), replace=False)
    
    H, xedges, yedges, binnumber = binned_statistic_2d(
        x[finite], y[finite], z[finite],
        statistic=function, bins=bins)

    if min_entries_per_bin is not None:
        if function != "count":
            H_count, xedges, yedges, binnumber = binned_statistic_2d(
                x[finite], y[finite], z[finite],
                statistic="count", bins=bins)

        else:
            H_count = H

        H[H_count < min_entries_per_bin] = np.nan
        if not np.any(np.isfinite(H)) or np.max(H) == 0:
            return (fig, None) if full_output else fig


    if (vmin is None or vmax is None) and "norm" not in kwargs:
        vmin_default, med, vmax_default = np.nanpercentile(H, kwargs.pop("norm_percentiles", [5, 50, 95]))
        if vmin is None:
            vmin = vmin_default
        if vmax is None:
            vmax = vmax_default
    
    imshow_kwds = dict(
        vmin=vmin, vmax=vmax,
        aspect=np.ptp(xedges)/np.ptp(yedges), 
        extent=(xedges[0], xedges[-1], yedges[-1], yedges[0]),
        cmap="inferno",
        interpolation="bilinear")
    imshow_kwds.update(kwargs)
    
    image = ax.imshow(H.T, **imshow_kwds)
    if colorbar:
        if orientation == "vertical":
            colorbar_kwds = dict(fraction=0.046, pad=0.04)
        else:
            colorbar_kwds = dict(fraction=0.026, pad=0.24)
        cbar = plt.colorbar(image, ax=ax, orientation=orientation, **colorbar_kwds)
        if zlabel is not None:
            cbar.set_label(zlabel)

    if xlabel is not None:
        ax.set_xlabel(xlabel)
    if ylabel is not None:
        ax.set_ylabel(ylabel)

    return (fig, image, H) if full_output else fig

```


```{python}
fig, ax = plt.subplots()
scat = ax.scatter(
    results["v_jkc_mag"] - results["k_mag"], 
    results["irfm_teff"], 
    s=1,  
    c=results["m_h_atm"]
)
cbar = plt.colorbar(scat)
cbar.set_label("[M/H]")
ax.set_xlabel("V-Ks")
ax.set_ylabel("IRFM Teff [K]")
None
```

Let's look how the temperatures differ first.
```{python}
fig, ax = plt.subplots()
x, y = (
    results["raw_teff"],
    (results["raw_teff"] - results["irfm_teff"]),
)
scat = ax.scatter(
    x,
    y,
    s=1,
    alpha=0.5,
    c=results["m_h_atm"],
)
cbar = plt.colorbar(scat)
cbar.set_label("[M/H]")
ax.set_xlabel("IRFM Teff [K]")
ax.set_ylabel("Raw Teff - IRFM Teff [K]")
None
```

Now let's look by log density:
```{python}
xi = np.linspace(3500, 5750, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y,
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=2,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

And if we colour by mean metallicity, we see a clear trend:
```{python}
xi = np.linspace(3500, 5750, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y,
    results["m_h_atm"],
    function="mean",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    full_output=True,
    min_entries_per_bin=2,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None

```


We could fit them simultaneously, but let's do things step-by-step and evaluate the trend with metallicity first.
```{python}
X = results["m_h_atm"]
Y = np.array([results["raw_teff"] - results["irfm_teff"]]).flatten()
use_in_fit = (
    (results["raw_teff"] > 3500)
&   (results["raw_teff"] < 5750)
&   (np.abs(Y) < 300)
)

phi = np.polyfit(X, Y, 1)
irfm_teff_fit = np.polyval(phi, X)

fig, im, H = plot_binned_statistic(
    results["m_h_atm"],
    Y,
    function="count",
    bins=100,
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=2,
    xlabel="[M/H] [dex]",
    ylabel="Raw Teff - IRFM Teff [K]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])

xi = np.linspace(-2.5, 0.25, 2)
yi = np.polyval(phi, xi)
fig.axes[0].plot(xi, yi)
None
```

OK, now let's see what the mean metallicity looks like when we remove the metallicity contribution:

```{python}
xi = np.linspace(3500, 5750, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y - np.polyval(phi, results["m_h_atm"]),
    results["m_h_atm"],
    function="mean",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    full_output=True,
    min_entries_per_bin=2,
    zlabel="[M/H]",
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff (- [M/H] contrib) - IRFM Teff [K]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

Now in log density, it should be slightly sharper after removing the metallicity contribution: 

```{python}
xi = np.linspace(3500, 5750, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y - np.polyval(phi, results["m_h_atm"]),
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=2,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

```{python}
xf, yf = ([], [])
for i, _xi in enumerate(xi[:-1] + 0.5 * np.diff(xi)):    
    if np.sum(np.isfinite(H[i])) > 10:
        xf.append(_xi)    
        yf.append(yi[np.nanargmax(H[i])] + 0.5 * np.diff(yi)[0])

xf, yf = (np.array(xf), np.array(yf))
xmin, xmax = (3500, 5500)
fit = (xf >= xmin) & (xf <= xmax)
theta = np.polyfit(xf[fit], yf[fit], 2)

teff_correction = np.polyval(theta, results["teff"]) + np.polyval(phi, results["m_h_atm"])
```

Now let's fit that shit out, and see how we look:

```{python}
xi = np.linspace(3000, 5750, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y - teff_correction,
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=1,
    xlabel="IRFM Teff [K]",
    ylabel="Calibrated Teff - IRFM Teff [K]",
    zlabel="N"
)
fig.axes[0].axhline(0, c="#666666", ls=":", lw=0.5)
None
```


Now let's compute some statistics:

```{python}
from IPython.display import Markdown
Markdown(f"The mean difference in effective temperature after corrections is {np.mean(y - teff_correction):.0f} K, with a scatter of {np.std(y - teff_correction):.0f} K")
```

And if this is implemented correctly in Astra, then below we should see *nearly* the same as what we saw above. The difference is that in Astra we have clipped the temperature offsets (no extrapolation), whereas in these QA plots we didn't clip them.

```{python}

fig, im, H = plot_binned_statistic(
    results["irfm_teff"],
    results["teff"] - results["irfm_teff"],
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=1,
    xlabel="IRFM Teff [K]",
    ylabel="Calibrated Teff - IRFM Teff [K]",
    zlabel="N"
)
fig.axes[0].axhline(0, c="#666666", ls=":", lw=0.5)
None
```


### Dwarfs

First let's select some low reddened stars with good flags.

```{python}

q = (
    ASPCAP
    .select(
        ASPCAP.source_pk,
        ASPCAP.spectrum_pk,
        ASPCAP.teff,
        ASPCAP.irfm_teff,
        ASPCAP.raw_teff,
        ASPCAP.logg,
        ASPCAP.raw_logg,
        ASPCAP.m_h_atm,        
        Source.v_jkc_mag,
        Source.k_mag,
        Source.ebv,
        Source.e_ebv,
        Source.ebv_flags,   
        ASPCAP.irfm_teff_flags,     
    )
    .distinct(ASPCAP.spectrum_pk)
    .join(Source)
    .where(
        ASPCAP.irfm_teff.is_null(False)
    &   (~ASPCAP.flag_ferre_fail)
    &   (~ASPCAP.flag_missing_model_flux)
    &   (~ASPCAP.flag_potential_ferre_timeout)
    &   (~ASPCAP.flag_no_suitable_initial_guess)
    &   (~ASPCAP.flag_spectrum_io_error)
    &   (~ASPCAP.flag_teff_grid_edge_warn)
    &   (~ASPCAP.flag_teff_grid_edge_bad)
    &   (~ASPCAP.flag_logg_grid_edge_warn)
    &   (~ASPCAP.flag_logg_grid_edge_bad)
    &   (~ASPCAP.flag_v_micro_grid_edge_warn)
    &   (~ASPCAP.flag_v_micro_grid_edge_bad)
    &   (~ASPCAP.flag_v_sini_grid_edge_warn)
    &   (~ASPCAP.flag_v_sini_grid_edge_bad)
    &   (~ASPCAP.flag_m_h_atm_grid_edge_warn)
    &   (~ASPCAP.flag_m_h_atm_grid_edge_bad)
    &   (~ASPCAP.flag_alpha_m_grid_edge_warn)
    &   (~ASPCAP.flag_alpha_m_grid_edge_bad)
    &   (~ASPCAP.flag_c_m_atm_grid_edge_warn)
    &   (~ASPCAP.flag_c_m_atm_grid_edge_bad)
    &   (~ASPCAP.flag_n_m_atm_grid_edge_warn)
    &   (~ASPCAP.flag_n_m_atm_grid_edge_bad)
    &   (Source.ebv < 0.02)
    &   (Source.ebv >= 0)
    &   (~ASPCAP.flag_out_of_fe_h_bounds)
    &   (~ASPCAP.flag_extrapolated_v_mag)
    &   (~ASPCAP.flag_poor_quality_k_mag)
    &   (~ASPCAP.flag_ebv_used_is_upper_limit)
    &   ASPCAP.flag_as_dwarf_for_irfm_teff 
    &   (fn.abs(ASPCAP.teff - ASPCAP.irfm_teff) < 500)
    &   (ASPCAP.raw_teff <= 8000)
    &   ~(Source.flag_ebv_from_edenhofer_2023) 
    )
    .dicts()    
)

results = Table(rows=list(q))
```

Plot the computed IRFM temperatures for dwarfs against their $V-Ks$ colour.
```{python}
fig, ax = plt.subplots()
scat = ax.scatter(
    results["v_jkc_mag"] - results["k_mag"], 
    results["irfm_teff"], 
    s=1,  
    c=results["m_h_atm"]
)
cbar = plt.colorbar(scat)
ax.set_xlabel("V - Ks")
ax.set_ylabel("IRFM Teff [K]")
cbar.set_label("[M/H]")
None
```

Now let's see how badly the FERRE temperatures look:
```{python}
xi = np.linspace(3500, 7000, 100)
yi = np.linspace(-500, 500, 100)

x, y = (
    results["raw_teff"],
    (results["raw_teff"] - results["irfm_teff"]),
)

fig, im, H = plot_binned_statistic(
    x,
    y,
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=2,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]",
    zlabel="N"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

Now let's find the *HUNGRY HUNGRY CATERPILLAR* by plotting the same thing by mean metallicity [M/H]:

```{python}
xi = np.linspace(3500, 7000, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y,
    results["m_h_atm"],
    function="mean",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    full_output=True,
    min_entries_per_bin=2,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]",
    zlabel="[M/H]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

Where we see another clear trend with metallicity, going the same direction as for the giants. Let's fit that shit out:

```{python}

X = results["m_h_atm"]
Y = np.array([results["raw_teff"] - results["irfm_teff"]]).flatten()
use_in_fit = (
    (results["raw_teff"] > 3500)
&   (results["raw_teff"] < 7000)
&   (np.abs(Y) < 300)
)

phi = np.polyfit(X, Y, 1)
irfm_teff_fit = np.polyval(phi, X)

fig, im, H = plot_binned_statistic(
    results["m_h_atm"],
    Y,
    function="count",
    bins=(
        np.linspace(-1.5, 0.5, 100),
        np.linspace(-500, 500, 100)
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=2,
    xlabel="[M/H]",
    ylabel="Raw Teff - IRFM Teff [K]",
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])

xi = np.linspace(-1, 0.5, 10)
fig.axes[0].plot(xi, np.polyval(phi, xi))
None

```

Ta da! We fit a bad line. So now after fitting that contribution out, we should see no trend with metallicity:
```{python}
xi = np.linspace(3500, 7000, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y - np.polyval(phi, results["m_h_atm"]),
    results["m_h_atm"],
    function="mean",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    full_output=True,
    min_entries_per_bin=1,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]",
    zlabel="[M/H]"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

Good, now let's go back to viewing in log density 
```{python}
xi = np.linspace(3500, 7000, 100)
yi = np.linspace(-500, 500, 100)
fig, im, H = plot_binned_statistic(
    x,
    y - np.polyval(phi, results["m_h_atm"]),
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=2,
    xlabel="IRFM Teff [K]",
    ylabel="Raw Teff - IRFM Teff [K]",
    zlabel="N"
)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
```

And by the magic of Hogwarts:

```{python}
# do some shit we aren't proud of
xf, yf = ([], [])
for i, _xi in enumerate(xi[:-1] + 0.5 * np.diff(xi)):
    if np.sum(np.isfinite(H[i])) > 1:
        xf.append(_xi)    
        yf.append(yi[np.nanargmax(H[i])] + 0.5 * np.diff(yi)[0])

xf, yf = (np.array(xf), np.array(yf))
xmin, xmax = (4500, 6250)
fit = (xf >= xmin) & (xf <= xmax)
theta = np.polyfit(xf[fit], yf[fit], 2)
teff_correction = np.polyval(theta, results["raw_teff"]) + np.polyval(phi, results["m_h_atm"])

xi = np.linspace(3000, 7000, 100)
yi = np.linspace(-1000, 1000, 100)
fig, im, H = plot_binned_statistic(
    x,
    y - teff_correction,
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=1,
    xlabel="IRFM Teff [K]",
    ylabel="Calibrated Teff - IRFM Teff [K]",
    zlabel="N"
)
fig.axes[0].axhline(0, c="#666666", ls=":", lw=0.5)
fig.axes[0].set_ylim(fig.axes[0].get_ylim()[::-1])
None
```

Now compute some statistics:
```{python}
Markdown(f"The mean difference in effective temperature from the IRFM scale for dwarfs is {np.mean(y - teff_correction):.0f} K, with a scatter of {np.std(y - teff_correction):.0f} K.")
```

If this is implemented correctly in Astra then we should see almost the same figure below (expect some differences outside of 4500 K and 6250 K):
```{python}
fig, im, H = plot_binned_statistic(
    results["irfm_teff"],
    results["teff"] - results["irfm_teff"],
    function="count",
    bins=(
        xi,
        yi
    ),
    interpolation="none",
    colorbar=True,
    norm=LogNorm(),
    full_output=True,
    min_entries_per_bin=1,
    xlabel="IRFM Teff [K]",
    ylabel="Calibrated Teff - IRFM Teff [K]",
    zlabel="N"
)
fig.axes[0].axhline(0, c="#666666", ls=":", lw=0.5)
None
```


## Main-sequence `logg` calibrations

This is based on a notebook provided by Zach Way.

```{python}

```


## Seismology

Here we cross-match the pipeline results to asteroseismic catalogs. The APOKASC catalog version 3 (7.0.5) was used for these comparisons. 
```{python}
apokasc, results, apokasc_indices, pipeline_indices = qa.prepare_apokasc_comparison(MODEL, COADD_SPECTRUM_MODEL)
```

Throughout this section we are only considering the results from the co-added spectra. @fig-apokasc-rgb-rc shows the difference in surface gravity for RGB/RC stars, where the classification of RGB vs RC comes from asteroseismology. 

```{python}
#| label: fig-apokasc-rgb-rc
#| fig-cap: "Difference in log(g) between this pipeline and APOKASC for red giant branch stars and red clump stars, where evolutionary states are determined from APOKASC."

fig = qa.plot_apokasc_rgb_rc_logg_comparison(apokasc[apokasc_indices], results[pipeline_indices])
```

In @fig-apokasc-logg-distributions we show the distribution of log(g) for the entire APOKASC sample, and those from this pipeline. Results are only shown for stars that are matched to the APOKASC sample (i.e., so the distributions should have the same number of stars in them), but the bin limits are restricted to between 0.5 and 4.0, so any logg values outside of this will not be shown.

```{python}
#| label: fig-apokasc-logg-distributions
#| fig-cap: "Distributions of log(g) for this pipeline and those in APOKASC, separated by evolutionary state (as determined by APOKASC)."
fig = qa.plot_apokasc_logg_distributions(apokasc[apokasc_indices], results[pipeline_indices], MODEL)
```

Finally, @fig-apokasc-kiel shows Kiel diagrams using results from this pipeline. Three views are shown: a histogram; a histogram coloured by the log counts; and a scatter plot coloured by the pipelinre-reported metallicity.
```{python}
#| label: fig-apokasc-kiel
#| fig-cap: "Kiel diagrams showing results from this pipeline for all stars in the APOKASC sample. The different panels show density, log density, and coloured by metallicity."
fig = qa.plot_hrd_of_apokasc_sample(results[pipeline_indices])
```

## Star clusters (OCCAM)

The Open Cluster Chemical Abundances and Mapping (OCCAM) Survey [@occam] produced a comprehensive APOGEE spectroscopic data set for hundreds of open clusters. 

Here we are using the OCCAM value added catalog associated with @myers:2022, with some additional restrictions: we require bonafide cluster members to be within 3 sigma of the cluster mean in proper motion, radial velocity, and metallicity. This restricted sample includes 95 high quality OCCAM clusters, but for these pages we have restricted it to clusters with 10 or more bonafide members. 

This restricted catalog was kindly prepared by Jonah Otto (TCU) and can be [accessed here](https://data.sdss5.org/sas/sdsswork/mwm/spectro/astra/aux/external-catalogs/high_quality_occam_cluster_stars_all.fits).


```{python}
from astra.models import Source
from astropy.table import Table
from astra.utils import expand_path

cluster_args = (MODEL, COADD_SPECTRUM_MODEL)

occam = Table.read(expand_path(f"$MWM_ASTRA/aux/external-catalogs/high_quality_occam_cluster_stars_all.fits"))
get_cluster_members = lambda name: tuple(occam["APOGEE_ID"][occam["CLUSTER"] == name])
```


### Berkeley 18
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Berkeley 18')), *cluster_args)
```


### Berkeley 85
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Berkeley 85')), *cluster_args)
```


### Briceno 1
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Briceno 1')), *cluster_args)
```


### Dolidze 41
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Dolidze 41')), *cluster_args)
```


### ESO 211 03
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('ESO 211 03')), *cluster_args)
```


### ESO 518 03
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('ESO 518 03')), *cluster_args)
```


### IC 166
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('IC 166')), *cluster_args)
```


### Kharchenko 1
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Kharchenko 1')), *cluster_args)
```


### Melotte 20
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Melotte 20')), *cluster_args)
```


### Melotte 22
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Melotte 22')), *cluster_args)
```


### NGC 1245
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 1245')), *cluster_args)
```


### NGC 1798
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 1798')), *cluster_args)
```


### NGC 1817
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 1817')), *cluster_args)
```


### NGC 188
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 188')), *cluster_args)
```


### NGC 2158
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 2158')), *cluster_args)
```


### NGC 2204
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 2204')), *cluster_args)
```


### NGC 2243
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 2243')), *cluster_args)
```


### NGC 2420
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 2420')), *cluster_args)
```


### NGC 2632
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 2632')), *cluster_args)
```


### NGC 2682
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 2682')), *cluster_args)
```


### NGC 6705
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 6705')), *cluster_args)
```


### NGC 6791
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 6791')), *cluster_args)
```


### NGC 6819
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 6819')), *cluster_args)
```


### NGC 7789
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('NGC 7789')), *cluster_args)
```


### Ruprecht 147
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Ruprecht 147')), *cluster_args)
```


### Trumpler 20
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Trumpler 20')), *cluster_args)
```


### Trumpler 5
```{python}
fig = qa.plot_cluster_view(COADD_SPECTRUM_MODEL.obj.in_(get_cluster_members('Trumpler 5')), *cluster_args)
```



## Star clusters (SDSS-IV targeting flags)

Cluster members in the following figures were selected from the SDSS-IV APOGEE targeting flags, which might candidate cluster members that the @occam survey discarded as non-members. Here we are only showing clusters with ten or more candidate members.

### M92
```{python}

fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m92, *cluster_args)
```
### M15
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m15, *cluster_args)
```
### M53
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m53, *cluster_args)
```
### NGC 5466
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_5466, *cluster_args)
```
### M2
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m2, *cluster_args)
```
### M13
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m13, *cluster_args)
```
### M3
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m3, *cluster_args)
```
### M5
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m5, *cluster_args)
```
### M12
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m12, *cluster_args)
```
### M107
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m107, *cluster_args)
```
### M71
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m71, *cluster_args)
```
### NGC 2158
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_2158, *cluster_args)
```
### M35
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m35, *cluster_args)
```
### NGC 2420
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_2420, *cluster_args)
```
### NGC 188
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_188, *cluster_args)
```
### M67
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m67, *cluster_args)
```
### NGC 7789
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_7789, *cluster_args)
```
### Pleiades
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_pleiades, *cluster_args)
```
### NGC 6819
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_6819, *cluster_args)
```
### Coma Berenices
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_coma_berenices, *cluster_args)
```
### NGC 6791
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_6791, *cluster_args)
```
### NGC 5053
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_5053, *cluster_args)
```
### M68
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m68, *cluster_args)
```
### NGC 6397
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_6397, *cluster_args)
```
### M55
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m55, *cluster_args)
```
### M22
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m22, *cluster_args)
```
### M79
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m79, *cluster_args)
```
### NGC 3201
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_3201, *cluster_args)
```
### M10
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m10, *cluster_args)
```
### NGC 6752
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_6752, *cluster_args)
```
### Omega Centauri
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_omega_centauri, *cluster_args)
```
### M54
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m54, *cluster_args)
```
### NGC 288
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_288, *cluster_args)
```
### NGC 362
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_362, *cluster_args)
```
### NGC 1851
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_1851, *cluster_args)
```
### M4
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_m4, *cluster_args)
```
### NGC 2808
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_2808, *cluster_args)
```
### 47TUC
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_47tuc, *cluster_args)
```
### NGC 6388
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_ngc_6388, *cluster_args)
```
### Draco
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_draco, *cluster_args)
```
### Ursa Minor
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_urminor, *cluster_args)
```
### Bootes 1
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_bootes1, *cluster_args)
```
### Sextans
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_sexans, *cluster_args)
```
### Fornax
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_fornax, *cluster_args)
```
### Sculptor
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_sculptor, *cluster_args)
```
### Carina
```{python}
fig = qa.plot_cluster_view(Source.flag_sdss4_apogee_member_carina, *cluster_args)
```




# Calibrations
## Error model

### Calibrated error

```{python}
fig = qa.plot_z_scores("ASPCAP")
```



## Field descriptions
```{python}
qa.render_data_model(MODEL)
```

## Flag definitions

The table below gives the pipeline flag definitions, their descriptions, and the number of times that flag is set `True` on a result in the database.

```{python}
qa.render_flag_definitions(MODEL)
```



```{python}
from datetime import datetime
from IPython.display import Markdown
Markdown(f"This page was built on {datetime.now()}.")
```
